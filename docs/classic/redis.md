### 1、Redis持久化机制，优缺点
a. RDB持久化是把当前进程数据生成快照保存到磁盘上的过程；针对RDB
不适合实时持久化的问题，Redis提供了AOF持久化方式来解决
<br>
b. AOF是“写后”命令，Redis
先执行命令把数据写入内存，然后才记录日志。日志里记录的是Redis
收到的每一条命令，这些命令是以文本形式保存。
<br>
c. Redis4.
0提出了一个混合使用AOF
日志和内存快照的方法，内存快照以一定的频率执行，在两次快照之间，使用AOF
日志记录这期间的所有命令操作。
<br>
这样一来，快照不用很频繁的执行，可以避免频繁fork对主线程的影响。而且AOF
日志也只用记录两次快照间的操作，不需要记录所有操作，因此就不会出现文件过大的问题了。这个方法既能享受到RDB文件快速恢复的好处，又能享受到AOF只记录操作命令的简单优势，实际环境中用的最多

### 2、RDB触发方式
触发RDB持久化的方式有2种，分别是手动触发和自动触发
<br>
<font color=#20B2AA>手动触发：</font>
<br>
a. save命令：阻塞当前Redis服务器，直到RDB
过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用
<br>
b. bgsave命令：Redis进程执行fork操作创建子进程，RDB
持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短
<br>
![bgsave执行流程](../pics/bg_save.png)
<br>
<font color=#20B2AA>自动触发：</font>
<br>
a. redis.conf配置save m n,
即在m秒内有n次修改时，自动触发bgsave生成RDB文件
<br>
b. 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点
<br>
c. 执行debug reload命令重新加载redis时也会触发bgsave操作
<br>
d. 默认情况下执行shutdown命令时，如果没有开启AOF持久化，也会触发bgsave操作

### 3、RDB同步硬盘时怎样保证数据一致性
RDB中的核心思路是copy-on-write
，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。
<br>
举个例子：如果主线程对这些数据也是读操作（例如图中的键值对A），那么主线程和bgsave
子进程相互不影响。但是如果主线程要修改一块数据（例如图中的键值对C
），那么这块数据就会被复制一份，生成该数据的副本。然后bgsave
子进程会把这个副本数据写入RDB文件，而这个过程中主线程仍然可以直接修改原来的数据。
<br>
![RDB同步硬盘](../pics/rdb_store.jpg)

### 4、AOF为什么采用写后日志
Redis要求高性能，采用写后日志有两方面好处：
<br>
1、避免额外的检查开销：Redis在向AOF
里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis在使用日志恢复数据时就可能会出错
<br>
2、不会阻塞当前的写操作
<br>
但这种方式存在潜在风险：
<br>
1、如果命令执行完成，写日志之前宕机了，会丢失数据
<br>
2、主线程写磁盘压力大，导致写盘慢，阻塞后续操作

### 5、AOF是怎样实现的
AOF日志记录Redis的每个写命令，步骤分为：命令追加、文件写入和文件同步
<br>
1、命令追加：当AOF
持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的aof_buf缓冲区
<br>
2、文件写入和同步：关于何时将aof_buf缓冲区的内容写入AOF文件中，Redis
提供了三种写回策略：
<br>
![](../pics/aof_impl.jpg)
<br>
a.always，同步写回：每个写命令执行完，立马同步的将日志写回磁盘
<br>
b.everysec，每秒写回：每个写命令执行完，只是先把日志写到AOF
文件的内存缓存区，每个一秒把缓冲区内容写入磁盘
<br>
c.no，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF
文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

### 6、AOF重写
#### 6.1、AOF重写会阻塞吗
AOF重写过程是由后台进程bgwriteaof来完成的。主线程fork
出后台的bgwriteaof子进程，fork会把主线程的内存拷贝一份给bgwriteaof
子进程，这里面就包含了数据库的最新数据。然后bgwriteaof
子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，计入重写日志。所以AOF
重写时在fork进程时是会阻塞住主线程的。

#### 6.2、AOF日志重写时机
有两个配置项控制AOF重写的触发：
<br>
1、auto-aof-rewrite-min-size：表示运行AOF
重写时文件的最小大小，默认为64MB
<br>
2、auto-aof-rewrite-percentage：这个值的计算方式是当前AOF
文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。

#### 6.3、AOF重写时新数据写入问题
重写过程总结为：一个拷贝，两处日志。在fork
出子进程时的拷贝以及在重写时，如果有新数据写入，主线程就会将命令记录到两个AOF
日志内存缓冲区中。如果AOF写回策略配置的是always
，则直接将命令写回旧的日志文件，并且保存一份命令至AOF
重写缓冲区，这些操作对新的日志文件是不存在影响的。
<br>
在bgwriteaof
子进程完成对日志文件的重写操纵后，会提示主线程已经完成重写操纵，主线程会将AOF
重写缓冲区中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF
重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后面通过Linux管道技术让AOF
重写期间就能同时进行回放，这样AOF重写结束后只需回放少量剩余的数据即可。
<br>
最后通过修改文件名的方式，保证文件切换的原子性。在AOF
重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。

#### 6.4、主线程fork出子进程时如何复制内存数据的
fork
采用操作系统提供的写时复制机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork
子进程时，子进程会拷贝父进程的页表，即虚拟映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量CPU资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。
<br>
但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。如下图（进程1看作是主进程，进程2
看作是子进程）：
<br>
![](../pics/aof_copy.png)
<br>
但主进程有数据写入时，而这个数据刚好在页C中，操作系统会创建这个页面的副本（页C
的副本），即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的页C。