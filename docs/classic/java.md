### 1 Java集合
#### 1.1 ArrayList扩容机制
每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出数组将会进行扩容以满足添加数据的需求。数组扩容通过ensureCapacity()方法来实现。
<br>
数组进行扩容时，会将老数组中元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时就指定其容量以避免数组扩容的发生。或者根据实际需求通过调用ensureCapacity方法来手动增加ArrayList的容量
![ArrayList扩容机制](../pics/arrayList_add.png)

#### 1.2 HashMap扩容机制
当HashMap中元素数量超过了负载因子(0.75)与当前容量的乘积，会触发扩容
<br>
扩容过程：
<br>
a. 当前容量翻倍
<br>
b. 重新计算hash，每个键的hash值会基于新的容量重新计算，并通过新的桶数组插入到相应的桶中
<br>
c. 元素迁移，在扩容过程中，所有的键值对会被重新计算位置并拷贝到新的桶数组，这需要遍历当前所有的链表或红黑树并重新插入到新位置

#### 1.3 为什么HashMap扩容为2的幂
a. 优化哈希计算，提高索引定位效率(位运算比%取模速度快)
<br>
HashMap计算key存储位置的公式为：
```
index = hash(key) & (capacity - 1)
```
b. 扩容时的优化，高低位拆分，优化数据迁移过程
<br>
JDK8中，HashMap扩容时采用高低位链表拆分，减少重新计算哈希的次数
<br>
传统计算扩容后索引方式需要对所有键值对重新计算hash & (newCapacity - 1)
<br>
优化方式：由于newCapacity = 2 * oldCapacity，新索引只取决于哈希值的某一位(oldCapacity对应的二进制位)
```
低位链表(index不变)：hash & oldCapacity == 0
高位链表(index + oldCapacity)：hash & oldCapacity != 0
```
### 2 JVM
#### 2.1 类加载的生命周期
类加载过程包括了加载、验证、准备、解析、初始化五个阶段。
<br>
a. 类加载：查找并加载类的二进制数据
<br>
b. 验证：确保被加载的类的正确性
<br>
c. 准备：未类的静态变量分配内存，并将其初始化为默认值
<br>
d. 解析：把类的符号引用转换为直接引用
<br>
e. 初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化
<br>
f. 卸载：结束生命周期

#### 2.2 双亲委派机制
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类
#### 2.3 JVM内存模型
线程私有：程序计数器、虚拟机栈、本地方法栈
<br>
线程共享：堆、方法区、堆外内存（JDK7的永久代或JDK8的元空间）
<br>
栈帧的内存结构：
> 局部变量表
> <br>
> 操作数栈
> <br>
> 动态链接：指向运行时常量池的方法引用
> <br>
> 方法返回地址：方法正常退出或异常推出的地址

方法区：
> 用于存储类信息、常量池、静态变量、JIT编译后的代码等数据。永久代是HotSpot虚拟机特有的概念，JDK8的时候被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。

#### 2.4 如何判断一个对象是否可以回收
1、引用计数算法
<br>
给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1,。引用计数为0的对象可被回收。
<br>
两个对象出现循环引用的时候，引用计数器永远不为0，导致无法对它们进行回收。因为循环引用的存在，JVM不使用引用计数方法

2、可达性分析算法
通过GC Roots作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象可被回收
<br>
JVM使用该算法来判断对象是否可被回收，在Java中GC Roots一般包含以下内容：
<br>
虚拟机栈中引用的对象
<br>
本地方法栈中引用的对象
<br>
方法区中类静态属性引用的对象
<br>
方法区中常量引用的对象

### 3 Java并发
#### 134